using System;
using UnityEngine;

public class ExploitCommand : ICommand
{
  private VirtualNetwork network;
  private CommandProcessor commandProcessor;
  private PlayerVulnerabilityInventory vulnerabilityInventory;
  private PlayerProgressManager progressManager;

  public string Name => "exploit";
  public string Description => "Exploit a vulnerability on a target system";
  public string Usage => "exploit <cve> <host> <port>";

  public ExploitCommand(VirtualNetwork network, CommandProcessor cmdProcessor,
                      PlayerVulnerabilityInventory inventory, PlayerProgressManager progress)
  {
    this.network = network;
    this.commandProcessor = cmdProcessor;
    this.vulnerabilityInventory = inventory;
    this.progressManager = progress;
  }

  public void Execute(string[] args, ITerminalOutput output)
  {
    if (args.Length < 3)
    {
      output.AppendText($"Usage: {Usage}\n");
      return;
    }

    string cve = args[0];
    string host = args[1];

    if (!int.TryParse(args[2], out int port))
    {
      output.AppendText("Port must be a number.\n");
      return;
    }

    output.AppendText($"Attempting to exploit {cve} on {host}:{port}...\n\n");

    // Find vulnerability in player's inventory
    VulnerabilityReference foundVuln = null;
    foreach (var vulnRef in vulnerabilityInventory.GetAllVulnerabilities())
    {
      // Case-insensitive CVE comparison
      bool cveMatches = vulnRef.Vulnerability.CVE.Equals(cve, StringComparison.OrdinalIgnoreCase);
      bool hostMatches = vulnRef.HostIP.Equals(host, StringComparison.OrdinalIgnoreCase);
      bool portMatches = vulnRef.Port == port;

      if (cveMatches && hostMatches && portMatches)
      {
        foundVuln = vulnRef;
        break;
      }
    }

    if (foundVuln == null)
    {
      output.AppendText($"Error: {cve} not found in your vulnerability database for {host}.\n");
      output.AppendText("You must scan for vulnerabilities before exploiting them.\n");

      // Suggest correct usage if we found a partial match
      bool anyCveMatch = false;
      foreach (var vuln in vulnerabilityInventory.GetAllVulnerabilities())
      {
        if (vuln.Vulnerability.CVE.Equals(cve, StringComparison.OrdinalIgnoreCase) &&
            vuln.HostIP.Equals(host, StringComparison.OrdinalIgnoreCase))
        {
          output.AppendText($"\nDid you mean: exploit {vuln.Vulnerability.CVE} {vuln.HostIP} {vuln.Port}\n");
          anyCveMatch = true;
          break;
        }
      }
      return;
    }

    // Get the target system
    RemoteSystem system = network.GetSystemByHostname(host);
    if (system == null)
    {
      output.AppendText($"Host {host} not found.\n");
      return;
    }

    // Check if the vulnerability exists on the target
    Software software = system.GetSoftwareOnPort(port);
    if (software == null)
    {
      output.AppendText($"No service found on port {port}.\n");
      return;
    }

    bool exploitSuccessful = false;
    foreach (var vuln in software.Vulnerabilities)
    {
      if (vuln.CVE == cve)
      {
        // Success! The vulnerability exists and can be exploited
        exploitSuccessful = true;

        // Animation-like feedback
        output.AppendText("Preparing exploit payload...\n");
        // We would add a delay here in a real game

        output.AppendText("Sending exploit...\n");
        // Another delay

        output.AppendText($"Vulnerability {cve} successfully exploited!\n\n");

        // Give escalated access
        system.GiveRootAccess();

        // For privilege escalation, give root access
        if (vuln.Type == VulnerabilityType.PrivilegeEscalation)
        {
          output.AppendText("Privilege escalation successful. You now have root access.\n");

          // Switch to the system with root access
          commandProcessor.SetFileSystem(system.FileSystem);
          commandProcessor.SetCurrentSystem(system);
        }
        // For RCE, open a shell
        else if (vuln.Type == VulnerabilityType.RemoteCodeExecution)
        {
          output.AppendText("Remote code execution successful. Shell opened.\n");

          // Switch to the system
          commandProcessor.SetFileSystem(system.FileSystem);
          commandProcessor.SetCurrentSystem(system);
        }

        break;
      }
    }

    if (!exploitSuccessful)
    {
      output.AppendText("Exploit failed. The vulnerability may have been patched.\n");
    }
  }
}
